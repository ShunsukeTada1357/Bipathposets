## This code is an implementation of A-type method which allows us to obtain intervals and ith basis from FSC of type A.
#This code generates a matrix encoding boundary operator of simplices. 
using AbstractAlgebra
function getB(FSC)
    FS =copy(FSC)
    n= length(FS[1])  
    B = zero_matrix(R,n,n)
    inj = FSCtoDict(FS) #injection: simplex -> index
    for i in 1:n
        if length(FS[1][i][1]) == 1 # boundary_operation(FS[1][i][1])==0
            #do nothing
        else
            S = boundary_operation(FS[1][i][1])
            for s in S
                B[inj[s],i] = 1
            end
        end
    end
    return B
end

#The output "change" gives the "good "(in terms of taking homology) basis of vector spaces generated by simplicies.
#The output "B" gives modified matrix. We can obtain barcode from the matrix.  

function getBhat_and_basechange(BB) #BB is a boundary matrix from a filtered simplicial complex over a field with two elements.
    Bhat = copy(BB)
    cols = size(BB)[2]
    col_change=[]
    
    if cols <= 1 
        return Bhat, col_change
    end

    for j in 2 : cols
        i =1
        #println(j,"/",cols)
        while i<j
            if  (find_lowest_nonzero(Bhat[:,i]) == find_lowest_nonzero(Bhat[:,j])) && find_lowest_nonzero(Bhat[:,j]) != -1
                Bhat[:,j] = Bhat[:,j]+Bhat[:,i]
                push!(col_change,[i,j])
                i= 1
            else
                i =i+1
            end 
        end
    end  
    return [Bhat,col_change]
end

function setF_Fdash_E(Bhat)
    Bhatt = copy(Bhat)
    n = size(Bhat)[2]
    F =[]
    bijFdashtoF = Dict()
    Fdash =[]
    E =[i for i in 1:n]
    for i in 1:n
        a = find_lowest_nonzero(Bhatt[:,i])
        if a >= 0
            push!(F,i)
            push!(Fdash,a)
            bijFdashtoF[a]=i
        end 
    end
    setdiff!(E,F)
    setdiff!(E,Fdash)
    return F, Fdash, E, bijFdashtoF
end

function get_intervals_with_basis(FSC,Bhat,info_col_change)
    FS = copy(FSC)
    n = length(FS[1])
    info = info_col_change
    ddd = Dict()
    newbasis = [[s[1]] for s in FS[1] ]
    basis =  [[s[1]] for s in FS[1]]

    for vec in info
        for i in 1 : length(newbasis[vec[1]])
             push!(newbasis[vec[2]],  newbasis[vec[1]][i])
        end
    end
 
    FFdashE = setF_Fdash_E(Bhat)
    Fdash = FFdashE[2]
    bijFdashtoF=FFdashE[4]
    E =FFdashE[3]
    imagebasis=[]

    for k in Fdash
        j = bijFdashtoF[k]
        basisI = [basis[i][1] for i in 1:n if Bhat[i,j] !=0 ]
        int = [k,j-1]
        ddd[basisI] = int
        push!(imagebasis,[basisI,int])
    end

    for i in E
        ddd[newbasis[i]] =[i,n]
    end
    pairs = sort(ddd;byvalue=true)
    return  [pairs,imagebasis]# it returns pairs of intervals and bases. 
end

function get_intervals_with_basis_contract(FSC,pairs)
    p= Dict()
    for a in keys(pairs)
        Int = contractinterval(pairs[a],FSC)
        if Int[1]<= Int[2]
            p[a] = contractinterval(pairs[a],FSC)
        end
    end
    return p
end

function imagebasis_left(imagebasis,FSC)
    left_image =[a[1] for a in imagebasis if contractinterval(a[2],FSC)[1]==1]
    return left_image
end

function baseswithintervals(FSC)
    fsc = [[FSC[1][i][1],i] for i in 1: length(FSC[1])]
    B = getB([fsc,"any"])
    Bhat = getBhat_and_basechange(B)
    info_col = Bhat[2]
    Bhat = Bhat[1]
    X = get_intervals_with_basis(FSC,Bhat,info_col)
    pairs = get_intervals_with_basis_contract(FSC,X[1])
    imagebasis = X[2]
    return [pairs,imagebasis_left(imagebasis,FSC), imagebasis]
    # it returns pairs (pairs of intervals and bases) and basis of image of boubdary operation.        
end

function dim_int_list(pairs)
    key = keys(pairs)
    lis =[]
    for k in key
        n = length(k[1])-1
        if (n in lis) == false 
            push!(lis,n)
        end
    end
    return Set(lis)
end
